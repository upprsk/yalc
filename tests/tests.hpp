#pragma once

#include <any>
#include <concepts>
#include <functional>
#include <string>
#include <string_view>
#include <vector>

#include "nlohmann/json_fwd.hpp"

namespace ut {

/// This is a homegrown snapshot based test suite microframework. The main idea
/// is that output is generated by the system and stored after review. In case
/// this output changes in subsequent runs, then we have a failed test.
///
/// As the universal storage mechanism we use JSON, more specifically
/// `nlohmann::json`. A test function is just a function that returns JSON.
///
/// There are some levels of logging (each extends the previous one):
///
/// - show just the final test results (success, failure, skipped, crashed).
/// - show intermediary test results.
/// - show a message for each failed/skipped/crashed test.
/// - show the output of each crashed test.
/// - show the output of each failed test (may be a diff using `--diff`) and
///   expected output.
/// - show a message for each passed test.

static constexpr int VERBOSE_LEVEL_MAX = 5;

/// Hold test options.
struct Options {
    int  verbose{};
    bool ask{};
    bool diff{};

    [[nodiscard]] constexpr auto show_results() const -> bool {
        return verbose >= 1;
    }

    [[nodiscard]] constexpr auto show_fails() const -> bool {
        return verbose >= 2;
    }

    [[nodiscard]] constexpr auto show_crashes() const -> bool {
        return verbose >= 3;
    }

    [[nodiscard]] constexpr auto show_output() const -> bool {
        return verbose >= 4;
    }

    [[nodiscard]] constexpr auto show_success() const -> bool {
        return verbose >= 5;
    }
};

/// Test context.
struct Context {
    /// send output that should be captured to here.
    FILE* out;

    /// The options given to `run`
    Options const& opt;

    /// List of names of parent tests
    std::vector<std::string_view> parents;

    [[nodiscard]] constexpr auto with_output(FILE* file) const -> Context {
        return {.out = file, .opt = opt, .parents = parents};
    }

    [[nodiscard]] constexpr auto with_parent(std::string_view parent_name) const
        -> Context {
        auto ctx = Context{.out = out, .opt = opt, .parents = parents};
        if (!parent_name.empty()) ctx.parents.push_back(parent_name);

        return ctx;
    }
};

/// Store a single test.
struct Test {
    using Func = std::function<nlohmann::json(Context const& ctx)>;

    std::string       name;
    std::vector<Test> children;
    Func              func;
};

/// The result of running tests.
struct Result {
    int success{};
    int failed{};
    int skipped{};
    int crashed{};

    [[nodiscard]] constexpr auto total() const -> int {
        return success + failed + skipped + crashed;
    }

    [[nodiscard]] constexpr auto failures() const -> int {
        return failed + crashed;
    }

    [[nodiscard]] constexpr auto has_failures() const -> bool {
        return failures();
    }
};

constexpr void operator+=(Result& lhs, Result const& rhs) {
    lhs.success += rhs.success;
    lhs.failed += rhs.failed;
    lhs.skipped += rhs.skipped;
    lhs.crashed += rhs.crashed;
}

// ============================================================================

struct skip_exception {};

constexpr void skip() { throw skip_exception{}; }

// ============================================================================

// create an empty test group with the given name. The name is more of a
// semantic choice, as it is functionally identical to a test beeing created
// empty with a name.
auto group(std::string name) -> Test;

/// add a test as a child of the given test.
void add(Test& t, Test child);
void add(Test& t, std::string name, Test::Func func);
void add(Test& t, std::string name, std::function<void()> func);

/// Create a test with the given name and function.
auto test(std::string name, Test::Func func) -> Test;

/// Run the given test. If the given test also has children, run all of them.
auto run(Options const& opt, Test const& t) -> Result;

}  // namespace ut

namespace yal::tests {

auto file_store() -> ut::Test;
auto integration() -> ut::Test;

}  // namespace yal::tests
