file     ::= { top_stmt } ;
top_stmt ::= func
           | def_decl
           | var_decl
           | import
           ;

func         ::= "func" { ID "." } ID [ "[" generic_args "]" ] "(" func_args ")" [ expr ] block ;
generic_args ::= generic_arg { "," generic_arg } ; (* FIXME: allow trailing commans *)
generic_arg  ::= ID [ ":" expr ] ;
func_args    ::= func_arg { "," func_args } ; (* FIXME: allow trailing commans *)
func_arg     ::= ID ":" expr ;

import ::= "import" STR [ "as" ID ];

(* Statements *)

stmt ::= expr ";"
       | return_stmt
       | if_stmt
       | while_stmt
       | block
       | def_decl
       | var_decl
       | assign
       ;

return_stmt ::= "return" [ open_expr_pack ] ";" ;
if_stmt     ::= "if" expr block [ "else" expr ] ;
while_stmt  ::= "while" expr block
              | "while" decl expr block
              ;

block ::= "{" { stmt } "}" ;

def_decl ::= "def" id_pack [ ":" expr ] "=" expr ";"
           | "def" id_pack ":" expr [ "=" expr ] ";"
           ;

var_decl ::= "var" id_pack [ ":" expr ] "=" expr ";"
           | "var" id_pack ":" expr [ "=" expr ] ";"
           ;

id_pack ::= ID { "," ID } ;

(* not all expressions are valid in the lhs, but we don't check for this during
   parsing *)
assign ::= expr ( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "|=" | "&=" | "^=" | "<<=" | ">>=") expr ";" ;

(* Expressions *)

expr           ::= logic_or ;

(* some languages call this tuples, but we don't have tuples, this is used for multiple returns/decls *)
open_expr_pack ::= expr { "," expr } ;      (* NOTE: no trailing commas here *)
expr_pack      ::= "(" open_expr_pack ")" ; (* FIXME: allow trailing commas *)

logic_or  ::= logic_and { "||" logic_and } ;
logic_and ::= bin_or { "&&" bin_or } ;

bin_or  ::= bin_xor { "|" bin_xor } ;
bin_xor ::= bin_and { "^" bin_and } ;
bin_and ::= equality { "&" equality } ;

equality   ::= comparison { ( "!=" | "==" ) comparison } ;
comparison ::= shift { ( ">" | "=>" | "<=" | "<" ) shift } ;
shift      ::= term { ( "<<" | ">>" ) term } ;
term       ::= factor { ( "+" | "-" ) factor } ;
factor     ::= cast { ( "*" | "/" | "%" ) cast } ;

cast  ::= unary { "as" unary } ;
unary ::= ( "!" | "+" | "-" | "~" | "&" | "?" ) unary
        | deref
        ;

deref ::= call { ".*" call } ;

call           ::= primary { "(" call_args ")" }      (* func call *)
                 | primary { "[" slice_or_index "]" } (* index/slicing *)
                 | primary { "." primary }            (* field *)
                 ;
call_args      ::= expr { "," expr }; (* FIXME: allow trailing commas *)
slice_or_index ::= expr
                 | [ expr ] ":" [ expr ]
                 ;

primary ::= "(" expr ")"
          | "." ID
          | expr_pack
          | array
          | pointer_type
          | struct_type
          | enum_type
          | number
          | STR
          | ID
          ;

array ::= "[" ( expr | "_" ) "]" expr "{" array_items "}" ;
array_items ::= expr { "," expr } ; (* FIXME: allow trailing commas *)

(* slices are treated as pointers *)
pointer_type ::= "[" [ "*" ] "]" [ "const" ] unary
               | "*" [ "const" ] unary
               ;

struct_type  ::= "struct" "{" [ struct_field { "," struct_field } ] "}" ;
struct_field ::= ID ":" expr [ "=" expr ] ;

enum_type  ::= "enum" [ "of" expr ] "{" [ enum_field { "," enum_field } ] "}" ;
enum_field ::= ID [ "=" expr ] ;

number  ::= INT | HEX | OCT | BIN | FLOAT ;
